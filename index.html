// ======================================================================
// IDLE HEROES: ASCENSION 2.0 - powered by Phaser.js
// ======================================================================

// --- CONFIGURA√á√ÉO DO JOGO ---
const config = {
    type: Phaser.AUTO, // Phaser tenta usar WebGL, sen√£o usa Canvas
    width: 800,
    height: 600,
    parent: 'game-container', // ID do div onde o canvas do jogo ser√° inserido
    physics: {
        default: 'arcade', // Sistema de f√≠sica simples
        arcade: {
            debug: false // Altere para true para ver os bodies de colis√£o
        }
    },
    scene: [BootScene, TitleScene, HeroSelectionScene, BattleScene], // Cenas do jogo
    scale: {
        mode: Phaser.Scale.FIT, // Ajusta o jogo √† tela mantendo propor√ß√µes
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    audio: {
        disableWebAudio: false // Habilita o Web Audio API
    }
};

let game = new Phaser.Game(config);

// --- CLASSE BASE PARA PERSONAGENS (HER√ìI/INIMIGO) ---
class Character extends Phaser.GameObjects.Sprite {
    constructor(scene, x, y, texture, frame, name, maxHp, attack) {
        super(scene, x, y, texture, frame);
        scene.add.existing(this);
        scene.physics.add.existing(this);

        this.name = name;
        this.maxHp = maxHp;
        this.currentHp = maxHp;
        this.attack = attack;
        this.isDead = false;

        // Configura√ß√µes f√≠sicas (para simular ataques e movimento)
        this.body.setCollideWorldBounds(true);
        this.body.setImmovable(true); // N√£o √© empurrado por outros objetos de f√≠sica

        // Barra de vida
        this.hpBar = scene.add.graphics();
        this.updateHpBar();

        // Anima√ß√£o inicial (ocioso)
        this.play(`${texture}_idle`);
    }

    takeDamage(amount) {
        this.currentHp -= amount;
        if (this.currentHp <= 0) {
            this.currentHp = 0;
            this.isDead = true;
            this.play(`${this.texture.key}_die`); // Anima√ß√£o de morte
            this.on('animationcomplete', () => {
                this.setVisible(false);
                this.hpBar.setVisible(false);
                this.destroy(); // Remove o sprite ap√≥s a anima√ß√£o de morte
            }, this);
        } else {
            this.scene.tweens.add({ // Efeito de "flash" ao tomar dano
                targets: this,
                alpha: 0.5,
                duration: 100,
                yoyo: true,
                ease: 'Power1'
            });
        }
        this.updateHpBar();
        this.scene.sound.play('hit_sound'); // Som de impacto
    }

    dealDamage(target) {
        if (!target.isDead) {
            target.takeDamage(this.attack);
            // Mostrar texto de dano
            this.scene.showDamageText(target.x, target.y - 50, this.attack);
            this.scene.sound.play('attack_sound'); // Som de ataque
        }
    }

    updateHpBar() {
        this.hpBar.clear();
        const barWidth = 60;
        const barHeight = 8;
        const barX = this.x - barWidth / 2;
        const barY = this.y - this.displayHeight / 2 - 15;

        // Fundo da barra
        this.hpBar.fillStyle(0x000000, 0.5);
        this.hpBar.fillRect(barX, barY, barWidth, barHeight);

        // Preenchimento da barra (verde)
        const hpPercent = this.currentHp / this.maxHp;
        this.hpBar.fillStyle(0x00ff00, 0.8);
        this.hpBar.fillRect(barX, barY, barWidth * hpPercent, barHeight);
    }

    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        this.updateHpBar(); // Mant√©m a barra de vida atualizada
    }
}

// --- CLASSE ESPEC√çFICA PARA HER√ìIS ---
class Hero extends Character {
    constructor(scene, x, y, texture, frame, name, maxHp, attack, level) {
        super(scene, x, y, texture, frame, name, maxHp, attack);
        this.level = level;
        this.setFlipX(true); // Virar para a direita
    }
}

// --- CLASSE ESPEC√çFICA PARA INIMIGOS ---
class Enemy extends Character {
    constructor(scene, x, y, texture, frame, name, maxHp, attack) {
        super(scene, x, y, texture, frame, name, maxHp, attack);
        this.setFlipX(false); // Virar para a esquerda
    }
}


// ======================================================================
// SCENA DE BOOT (Carregamento de Assets)
// ======================================================================
class BootScene extends Phaser.Scene {
    constructor() {
        super('Boot');
    }

    preload() {
        // Obter elementos da tela de carregamento
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingText = document.getElementById('loading-text');

        // Eventos de progresso do carregamento
        this.load.on('progress', (value) => {
            loadingProgress.style.width = (value * 100) + '%';
            loadingText.textContent = Math.round(value * 100) + '%';
        });

        this.load.on('complete', () => {
            loadingScreen.style.display = 'none'; // Esconde a tela de carregamento
        });

        // --- CARREGAMENTO DE IMAGENS ---
        this.load.image('battle_bg', 'assets/images/battle_bg.png'); // Imagem de fundo

        // Carregar spritesheets para anima√ß√µes
        // Supondo que 'hero_sprite.png' e 'enemy_sprite.png' s√£o spritesheets
        // Voc√™ precisar√° ajustar frameWidth e frameHeight conforme suas imagens
        this.load.spritesheet('hero_sprite', 'assets/images/hero_sprite.png', { frameWidth: 64, frameHeight: 64 });
        this.load.spritesheet('enemy_sprite', 'assets/images/enemy_sprite.png', { frameWidth: 64, frameHeight: 64 });

        // --- CARREGAMENTO DE √ÅUDIO ---
        this.load.audio('attack_sound', 'assets/audio/attack_sound.mp3'); // Som de ataque
        this.load.audio('hit_sound', 'assets/audio/hit_sound.mp3');     // Som de impacto (opcional, mas bom ter)
        this.load.audio('bg_music', 'assets/audio/bg_music.mp3');       // M√∫sica de fundo (opcional)
    }

    create() {
        // Cria as anima√ß√µes para os sprites
        this.anims.create({
            key: 'hero_sprite_idle',
            frames: this.anims.generateFrameNumbers('hero_sprite', { start: 0, end: 3 }), // Ajuste os frames conforme seu spritesheet
            frameRate: 8,
            repeat: -1
        });
        this.anims.create({
            key: 'hero_sprite_attack',
            frames: this.anims.generateFrameNumbers('hero_sprite', { start: 4, end: 7 }), // Ajuste os frames
            frameRate: 10,
            repeat: 0
        });
        this.anims.create({
            key: 'hero_sprite_die',
            frames: this.anims.generateFrameNumbers('hero_sprite', { start: 8, end: 11 }), // Ajuste os frames
            frameRate: 6,
            repeat: 0
        });

        this.anims.create({
            key: 'enemy_sprite_idle',
            frames: this.anims.generateFrameNumbers('enemy_sprite', { start: 0, end: 3 }), // Ajuste os frames
            frameRate: 8,
            repeat: -1
        });
        this.anims.create({
            key: 'enemy_sprite_attack',
            frames: this.anims.generateFrameNumbers('enemy_sprite', { start: 4, end: 7 }), // Ajuste os frames
            frameRate: 10,
            repeat: 0
        });
        this.anims.create({
            key: 'enemy_sprite_die',
            frames: this.anims.generateFrameNumbers('enemy_sprite', { start: 8, end: 11 }), // Ajuste os frames
            frameRate: 6,
            repeat: 0
        });

        this.scene.start('Title'); // Inicia a cena do t√≠tulo ap√≥s carregar
    }
}


// ======================================================================
// SCENA DE T√çTULO (Tela Inicial)
// ======================================================================
class TitleScene extends Phaser.Scene {
    constructor() {
        super('Title');
    }

    create() {
        this.add.text(this.cameras.main.width / 2, this.cameras.main.height / 2 - 50, 'IDLE HEROES: ASCENSION', {
            fontSize: '32px',
            fill: '#ffd166'
        }).setOrigin(0.5);

        const startButton = this.add.text(this.cameras.main.width / 2, this.cameras.main.height / 2 + 50, 'INICIAR JORNADA', {
            fontSize: '24px',
            fill: '#7ce7c7',
            backgroundColor: '#222'
        }).setPadding(10).setOrigin(0.5).setInteractive();

        startButton.on('pointerdown', () => {
            this.scene.start('HeroSelection'); // Vai para a sele√ß√£o de her√≥is
        });
    }
}


// ======================================================================
// SCENA DE SELE√á√ÉO DE HER√ìIS (Mockup)
// ======================================================================
class HeroSelectionScene extends Phaser.Scene {
    constructor() {
        super('HeroSelection');
        this.selectedHeroes = [];
        this.availableHeroes = []; // Her√≥is que o jogador possui
    }

    init(data) {
        // Se houver dados passados, usa-os (por exemplo, her√≥is salvos)
        if (data && data.playerHeroes) {
            this.availableHeroes = data.playerHeroes;
        } else {
            // Her√≥is iniciais para teste se n√£o houver jogo salvo
            this.availableHeroes = [
                { id: 1, name: "Aurora", texture: "hero_sprite", level: 1, base_attack: 10, base_hp: 100 },
                { id: 2, name: "Kael", texture: "hero_sprite", level: 1, base_attack: 8, base_hp: 80 },
                { id: 3, name: "Evelyn", texture: "hero_sprite", level: 1, base_attack: 12, base_hp: 70 }
            ];
        }
        // Pr√©-seleciona os 3 primeiros her√≥is para a batalha
        this.selectedHeroes = this.availableHeroes.slice(0, Math.min(3, this.availableHeroes.length));
    }

    create() {
        this.add.text(this.cameras.main.width / 2, 50, 'Selecione seus Her√≥is (Max 3)', {
            fontSize: '24px',
            fill: '#ffd166'
        }).setOrigin(0.5);

        // Placeholder para a lista de her√≥is
        this.add.text(this.cameras.main.width / 2, 150, 'HER√ìIS DISPON√çVEIS AQUI (Cliques para selecionar/desselecionar)', {
            fontSize: '16px',
            fill: '#a0a0b0'
        }).setOrigin(0.5);

        this.displaySelectedHeroes();

        const battleButton = this.add.text(this.cameras.main.width / 2, this.cameras.main.height - 80, 'IR PARA BATALHA', {
            fontSize: '24px',
            fill: '#7ce7c7',
            backgroundColor: '#222'
        }).setPadding(10).setOrigin(0.5).setInteractive();

        battleButton.on('pointerdown', () => {
            if (this.selectedHeroes.length > 0) {
                this.scene.start('Battle', { playerHeroes: this.selectedHeroes });
            } else {
                alert('Selecione pelo menos um her√≥i!');
            }
        });

        // Adicionar um bot√£o tempor√°rio para testar o Gacha e ter mais her√≥is
        const gachaButton = this.add.text(this.cameras.main.width - 20, 20, 'Gacha (Teste)', {
            fontSize: '16px',
            fill: '#9c27b0',
            backgroundColor: '#222'
        }).setOrigin(1, 0).setPadding(5).setInteractive();

        gachaButton.on('pointerdown', () => {
            // L√≥gica simplificada de gacha para adicionar um novo her√≥i
            const newHero = {
                id: Date.now(),
                name: "Novo Recruta",
                texture: "hero_sprite",
                level: 1,
                base_attack: 7 + Math.floor(Math.random() * 5),
                base_hp: 70 + Math.floor(Math.random() * 30)
            };
            this.availableHeroes.push(newHero);
            alert(`Voc√™ recrutou: ${newHero.name}!`);
            this.displaySelectedHeroes(); // Atualiza a exibi√ß√£o
        });
    }

    // Fun√ß√£o para exibir visualmente os her√≥is selecionados (melhoria futura: sprites clic√°veis)
    displaySelectedHeroes() {
        // Limpa qualquer exibi√ß√£o anterior de her√≥is selecionados
        if (this.selectedDisplayGroup) {
            this.selectedDisplayGroup.destroy(true);
        }
        this.selectedDisplayGroup = this.add.group();

        this.add.text(this.cameras.main.width / 2, 250, 'Time Selecionado:', {
            fontSize: '18px',
            fill: '#e0e0f0'
        }).setOrigin(0.5);

        this.selectedHeroes.forEach((hero, index) => {
            const xPos = this.cameras.main.width / 2 - 100 + (index * 100);
            const yPos = 300;
            const heroSprite = this.add.sprite(xPos, yPos, hero.texture).setScale(1.5);
            heroSprite.setInteractive();
            heroSprite.on('pointerdown', () => {
                // Ao clicar, remove/adiciona da sele√ß√£o (muito simples, sem UI visual de sele√ß√£o)
                const existingIndex = this.selectedHeroes.findIndex(h => h.id === hero.id);
                if (existingIndex > -1) {
                    this.selectedHeroes.splice(existingIndex, 1);
                } else if (this.selectedHeroes.length < 3) {
                    this.selectedHeroes.push(hero);
                }
                this.displaySelectedHeroes(); // Re-renderiza a lista selecionada
            });
            this.selectedDisplayGroup.add(heroSprite);
            this.selectedDisplayGroup.add(this.add.text(xPos, yPos + 40, hero.name, { fontSize: '12px', fill: '#fff' }).setOrigin(0.5));
        });
    }
}


// ======================================================================
// SCENA DE BATALHA (Onde a Magia Acontece)
// ======================================================================
class BattleScene extends Phaser.Scene {
    constructor() {
        super('Battle');
        this.playerHeroes = [];
        this.enemies = [];
        this.isBattleActive = false;
        this.battleTimerEvent = null; // Para o loop de combate
        this.music = null; // Para a m√∫sica de fundo
        this.soundEnabled = true; // Estado do som
    }

    init(data) {
        if (data && data.playerHeroes) {
            this.playerHeroesData = data.playerHeroes;
        } else {
            // Her√≥is padr√£o se n√£o vierem da sele√ß√£o
            this.playerHeroesData = [
                { id: 1, name: "Aurora", texture: "hero_sprite", level: 1, base_attack: 10, base_hp: 100 },
            ];
        }
    }

    create() {
        this.add.image(400, 300, 'battle_bg').setDisplaySize(config.width, config.height);

        this.setupUI(); // Configura HUD e controles
        this.setupAudio(); // Configura m√∫sica e som

        // Instanciar her√≥is
        const heroPositions = [
            { x: 150, y: 350 },
            { x: 180, y: 450 },
            { x: 120, y: 250 }
        ];
        this.playerHeroesData.forEach((heroData, index) => {
            if (index < heroPositions.length) {
                const { x, y } = heroPositions[index];
                const hero = new Hero(this, x, y, heroData.texture, 0, heroData.name, heroData.base_hp * heroData.level, heroData.base_attack * heroData.level, heroData.level);
                this.playerHeroes.push(hero);
            }
        });

        // Instanciar inimigos (mais complexo para N inimigos)
        const enemy = new Enemy(this, 650, 350, 'enemy_sprite', 0, 'Evil Ogre', 500, 20);
        this.enemies.push(enemy);

        this.isBattleActive = true;
        this.startCombatLoop();
    }

    setupUI() {
        // Bot√£o para retornar √† sele√ß√£o de her√≥is
        const backButton = this.add.text(20, 20, '<< VOLTAR', {
            fontSize: '16px',
            fill: '#fff',
            backgroundColor: '#555'
        }).setPadding(5).setInteractive();
        backButton.on('pointerdown', () => {
            this.stopAudio();
            this.scene.start('HeroSelection', { playerHeroes: this.playerHeroesData }); // Passa her√≥is de volta
        });

        // Bot√£o de toggle de som
        const soundButton = this.add.text(config.width - 20, 20, 'üîä', {
            fontSize: '20px',
            fill: '#fff',
            backgroundColor: '#555'
        }).setOrigin(1, 0).setPadding(5).setInteractive();
        soundButton.on('pointerdown', () => {
            this.toggleSound();
            soundButton.setText(this.soundEnabled ? 'üîä' : 'üîá');
        });
    }

    setupAudio() {
        if (!this.music) {
            this.music = this.sound.add('bg_music', { loop: true, volume: 0.3 });
            if (this.soundEnabled) {
                this.music.play();
            }
        }
        // Os sons de ataque e hit s√£o carregados no boot e reproduzidos diretamente
    }

    toggleSound() {
        this.soundEnabled = !this.soundEnabled;
        if (this.soundEnabled) {
            this.sound.mute = false;
            if (this.music && !this.music.isPlaying) {
                this.music.play();
            }
        } else {
            this.sound.mute = true;
        }
    }

    stopAudio() {
        if (this.music && this.music.isPlaying) {
            this.music.stop();
        }
    }

    startCombatLoop() {
        // O loop de combate acontece a cada 1 segundo (como um jogo idle)
        this.battleTimerEvent = this.time.addEvent({
            delay: 1000,
            callback: this.performCombatRound,
            callbackScope: this,
            loop: true
        });
    }

    performCombatRound() {
        if (!this.isBattleActive) return;

        // Her√≥is atacam inimigos
        this.playerHeroes.forEach(hero => {
            if (!hero.isDead && this.enemies.some(e => !e.isDead)) {
                hero.play(`${hero.texture.key}_attack`); // Anima√ß√£o de ataque
                hero.on('animationcomplete', () => {
                    hero.play(`${hero.texture.key}_idle`); // Volta para idle
                    const target = this.enemies.find(e => !e.isDead); // Primeiro inimigo vivo
                    if (target) hero.dealDamage(target);
                }, this, true); // O 'true' garante que o evento √© removido ap√≥s a primeira vez
            }
        });

        // Inimigos atacam her√≥is
        this.enemies.forEach(enemy => {
            if (!enemy.isDead && this.playerHeroes.some(h => !h.isDead)) {
                enemy.play(`${enemy.texture.key}_attack`); // Anima√ß√£o de ataque
                enemy.on('animationcomplete', () => {
                    enemy.play(`${enemy.texture.key}_idle`); // Volta para idle
                    const target = this.playerHeroes.find(h => !h.isDead); // Primeiro her√≥i vivo
                    if (target) enemy.dealDamage(target);
                }, this, true);
            }
        });

        this.checkBattleEnd();
    }

    checkBattleEnd() {
        const allHeroesDead = this.playerHeroes.every(h => h.isDead);
        const allEnemiesDead = this.enemies.every(e => e.isDead);

        if (allHeroesDead) {
            this.isBattleActive = false;
            this.battleTimerEvent.destroy();
            this.add.text(this.cameras.main.width / 2, this.cameras.main.height / 2, 'DERROTA!', {
                fontSize: '48px',
                fill: '#f44336'
            }).setOrigin(0.5);
            console.log('Todos os her√≥is morreram!');
        } else if (allEnemiesDead) {
            this.isBattleActive = false;
            this.battleTimerEvent.destroy();
            this.add.text(this.cameras.main.width / 2, this.cameras.main.height / 2, 'VIT√ìRIA!', {
                fontSize: '48px',
                fill: '#4CAF50'
            }).setOrigin(0.5);
            // Implementar recompensas aqui
            console.log('Todos os inimigos foram derrotados!');
        }
    }

    // Fun√ß√£o para exibir texto de dano flutuante
    showDamageText(x, y, damage) {
        const damageText = this.add.text(x, y, `-${damage}`, {
            fontSize: '20px',
            fill: '#f44336',
            stroke: '#000',
            strokeThickness: 4
        }).setOrigin(0.5);

        this.tweens.add({
            targets: damageText,
            y: y - 50, // Move para cima
            alpha: 0, // Desaparece
            duration: 1000,
            ease: 'Power1',
            onComplete: () => {
                damageText.destroy(); // Remove o texto ap√≥s a anima√ß√£o
            }
        });
    }
}
